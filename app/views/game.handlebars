<h1>Vee/Ess</h1>
<script type="text/javascript">
var game = new Phaser.Game(800, 600, Phaser.AUTO, '', { preload: preload, create: create, update: update });

function preload() {
    game.load.spritesheet('thor', '/assets/images/Thor.png', 32, 32);
}

var ship1;
function create() {
    game.time.desiredFps = 30;
    game.physics.startSystem(Phaser.Physics.ARCADE);
    ship1 = game.add.sprite(200, 200, 'thor', 1);
    ship1.name = "Thor"
    ship1.animations.add('moving', [0,1,2,3], 8, true);
    ship1.animations.add('stopped', [0]);
    ship1.animations.play('stopped');
    ship1.anchor.setTo(0.5);
    game.physics.arcade.enable(ship1);
    ship1.body.drag.set(50);
    ship1.body.maxVelocity.set(500);
}

function moveForward(sprite, speed) {
 game.physics.arcade.accelerationFromRotation(sprite.rotation - (Math.PI/2), speed, ship1.body.acceleration);
}

var maxAngularAcceleration = 0.5;
var maxAngularVelocity = 10;
function setNextAngle(sprite, desiredAngle) {
    currentAngle = sprite.angle;
    currentAngularVelocity = sprite.angularVelocity || 0;
    
    angleError = Math.abs(desiredAngle - currentAngle);
    var relativeVelocity = desiredAngle < currentAngle ? -1 : 1;
    if (angleError > 180) {
        relativeVelocity = relativeVelocity * -1;
        angleError = Math.abs(angleError - 360);
    }
    
    // Base Case: angleError is within angular acceleration
    if (angleError <= Math.max(maxAngularAcceleration, 2)) {
        sprite.angularVelocity = relativeVelocity * angleError;
        sprite.angle = desiredAngle;
        console.log('setting angle to: '+ desiredAngle);
        return;
    }
    
    console.log('------------------------------');
    console.log('current angle: ' + currentAngle);
    console.log('desired angle: ' + desiredAngle);
    console.log('angle error: ' + angleError);
    
    // Choose some new velocity within range of current
    // velocity such that 
    // (angleError - VInRange) >= stopping distance
    // stopping distance is equal to
    // (VInRange / 2) * (VInRange/maxAngularAcceleration - 1);
    // http://www.wolframalpha.com/input/?i=solve+for+x+:+%5B%2F%2Fmath:y-x+%3E%3D+(x+%2F+2)+*+(x%2Fz+-+1)%2F%2F%5D
    bestVelocity = 0.5 * Math.sqrt(8*angleError*maxAngularAcceleration + maxAngularAcceleration^2) - (maxAngularAcceleration/2);
    console.log('best: ' + bestVelocity);
    
    tickMaxVelocity = Math.min(relativeVelocity * currentAngularVelocity + maxAngularAcceleration, maxAngularVelocity);
    console.log('tick max: ' + tickMaxVelocity);
    
    achieveableVelocity = relativeVelocity * Math.min(tickMaxVelocity, bestVelocity);
    console.log('achieveable: ' + achieveableVelocity);
    
    sprite.angularVelocity = achieveableVelocity;
    sprite.angle = currentAngle + achieveableVelocity;
}

var desiredAngle = 0;
var response = null;
function update() {
    if (game.input.mousePointer.isDown) {
        closestPoint = closestVirtualPoint(ship1.position, game.input.mousePointer.position);
        console.log(closestPoint);
        desiredAngle =  Math.floor(Phaser.Math.radToDeg(Phaser.Math.angleBetweenPoints(ship1.position, closestPoint))) + 90; //sprite image is rotated 90 degrees... need better fix for this
        if (desiredAngle > 180) {
            desiredAngle = desiredAngle - 360;
        }
        
        response = null;
        socket.emit('tick', { 
            opponentPosition: [closestPoint.x, closestPoint.y],
            angle: desiredAngle
        }, function (res) {
            console.log(res);
            response = res;
        });
        
        //while (response == null) {}
        moveForward(ship1, 50);
        ship1.animations.play('moving');
    } else {
        ship1.body.acceleration.set(0);
        ship1.animations.play('stopped');
    }
    
    setNextAngle(ship1, desiredAngle);
    game.world.wrap(ship1);
}
    
function closestVirtualPoint(basePoint, relativePoint) {
    // if x diff of x values is less than game.width then 
    // both points are in the same x hemisphere
    var xDiff = basePoint.x - relativePoint.x;
    var sameXHemisphere = Math.abs(xDiff) > game.width;
    // same for y hemisphere
    var yDiff = basePoint.y - relativePoint.y;
    var sameYHemisphere = yDiff > game.height;
    
    // if both are the same then they are in the same 
    // quadrant and the closest path is the direct path
    if (sameXHemisphere && sameYHemisphere) {
        return relativePoint;
    }
    
    var points = [];
    
    // if only one hemisphere is shared
    var yDirection = Math.sign(yDiff);
    var adjustedY = yDirection * game.height + relativePoint.y;
    var xDirection = Math.sign(xDiff);
    var adjustedX = xDirection * game.width + relativePoint.x;
    if (!sameYHemisphere) {
        points.push(new Phaser.Point(relativePoint.x, adjustedY));
    }
    
    if (!sameXHemisphere) {
        points.push(new Phaser.Point(adjustedX, relativePoint.y));
    }
    
    if (!sameXHemisphere && !sameYHemisphere) {
        points.push(new Phaser.Point(adjustedX, adjustedY));
    }
    
    var closestPoint = relativePoint;
    var closestDistance = Phaser.Math.distance(basePoint.x, basePoint.y, relativePoint.x, relativePoint.y);
    points.forEach(function(point) {
        distance = Phaser.Math.distance(basePoint.x, basePoint.y, point.x, point.y);
        if (distance < closestDistance) {
            closestDistance = distance;
            closestPoint = point;
        }
    });
    
    return closestPoint;
}

var socket = io.connect('http://localhost:3000');
//socket.on('tickResponse', function (data) {
//    response = data;
//});
</script>

